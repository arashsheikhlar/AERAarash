;properties
weight:(ont 1) [[SYNC_ONCE now 0 forever root nil]];
size:(ont 1) [[SYNC_ONCE now 0 forever root nil]];

;values
large:(ont 1) [[SYNC_ONCE now 1 forever root nil]]
small:(ont 1) [[SYNC_ONCE now 1 forever root nil]]
lightweight:(ont 1) [[SYNC_ONCE now 1 forever root nil]]
heavyweight:(ont 1) [[SYNC_ONCE now 1 forever root nil]]

h:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
h_is_an_hand:(mk.val h essence hand 1) |[]
(fact h_is_an_hand 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

c:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
c_is_lightweight:(mk.val c weight lightweight 1) |[]
(fact c_is_lightweight 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]
c_is_small:(mk.val c size small 1) |[]
(fact c_is_small 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

s:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
s_is_lightweight:(mk.val s weight lightweight 1) |[]
(fact s_is_lightweight 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]
s_is_large:(mk.val s size large 1) |[]
(fact s_is_large 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]


; Internal state used by the programs to emulate the environment.
; (mk.val e1 emulator_state [Attached_obj_c Attached_obj_s])
e1:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
emulator_state:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
; Inject the emulator state into the emulator group.
emulator:(std_grp 2 0 0 0 |[]) [[SYNC_ONCE now 0 forever root nil COV_OFF 0]]



; This program runs in the primary group to re-inject any (fact (goal (fact (cmd ::)))) into emulator.
pgm_inject_in_emulator_group:(pgm |[]
[]
   (ptn f_G:(fact G:(goal (fact (cmd ::) ::) ::) ::) |[])
[]
   ; Only re-inject non-simulation goals.
   (= (is_sim G) false)
[]
   (inj [f_G [SYNC_ONCE (now) 1 1 emulator nil]])
1) |[]
(ipgm pgm_inject_in_emulator_group |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]

; Initial conditions.
start:(pgm |[] |[] |[] []
   (inj []
      State:(mk.val e1 emulator_state [nil nil] 1)
      |[]
   )
   (inj []
      (fact State After:(now) (+ After sampling_period) 1 1)
      [SYNC_PERIODIC now 1 1 emulator nil]
   )
1) |[]
(ipgm start |[] RUN_ONCE sampling_period VOLATILE NOTIFY 1) [[SYNC_ONCE now 0 forever stdin nil 1]]

m_drive:(mdl [] []
   ; The goal target timings are the same as the drive timings.
   (fact (mk.val h holding [s] 1) T0: T1: 1 1)
   (fact run T0: T1: ::)
|[]
|[]
[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]

pgm_babbleA_1:(pgm |[]
[]
   ; This fact repeats periodically. We use it as a "heartbeat".
   (ptn (fact (mk.val h essence hand :) After: Before: ::) |[])
[]
   (>= After (+ this.vw.ijt 100ms))
[]
   (inj []
      Command:(cmd grab [c] 1)
      |[]
   )
   (inj []
      f_Command:(fact Command After Before 1 1)
      |[]
   )
   (inj []
      G:(goal f_Command self nil 1)
      |[]
   )
   (inj []
      ; Delay a little to allow predictions for this sampling period before injecting the drive.
      (fact G T0:(+ After 10ms) T0 1 1)
      [SYNC_ONCE T0 1 forever primary nil]
   )
   (prb [1 "print" "injected (cmd grab [c])" |[]])
1) |[]
(ipgm pgm_babbleA_1 |[] RUN_ONCE MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]

; Reset Environment.
pgm_reset:(pgm |[] 
[]
   (ptn (fact (mk.val e1 emulator_state [Attached_obj_c: Attached_obj_s:] :) After: Before: ::) [])
[]
   (= After (+ this.vw.ijt 200ms))
[]
   (inj [Next_state:(mk.val e1 emulator_state [nil nil] 1) []])
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_ONCE (+ After sampling_period) 1 1 emulator nil]
   )
   (prb [1 "print" "RESET" |[]])
1) |[]
(ipgm pgm_reset [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]





pgm_inject_drive:(pgm [] []
   ; This fact repeats periodically. We use it as a "heartbeat".
   (ptn (fact (mk.val h essence hand :) After: Before: ::) [])
[]
   (>= After (+ this.vw.ijt 300ms))
[]
   ; The end of the time interval will be used in m_drive as the end of the goal interval.
   (inj [f_run:(fact run After (+ Before 300ms) 1 1) []])
   (inj [G:(goal f_run self nil 1) []])
   (inj []
      ; Delay a little to allow predictions for this sampling period before injecting the drive.
      (fact G T0:(+ After 10ms) T0 1 1)
      [SYNC_ONCE T0 1 forever primary nil]
   )
   (prb [1 "print" "injected drive" []])
1) |[]
(ipgm pgm_inject_drive [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]

pgm_cmd_grab_c:(pgm |[]
[]
   (ptn (fact G:(goal (fact Command:(cmd grab [c] ::) Cmd_after: Cmd_before: ::) ::) ::) |[])
   (ptn (fact (mk.val e1 emulator_state [nil nil] :) After: Before: ::) |[])
[]
   (= (is_sim G) false)
   (< Cmd_after Before)
   (> Cmd_before After)
[]
   ; Inject the fact that the command was executed.
   (inj []
      (fact Command (+ After 20ms) Before 1 1)
      [SYNC_ONCE After 1 1 stdin nil]
   )
   ; We already checked that sphere is at the hand's position. TODO: What if cube is also there? 
   (inj []
      Next_state:(mk.val e1 emulator_state [c nil] 1)
      |[]
   )
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
   )
   (prb [1 "print" "pgm_cmd_grab_c from command:" [Command]])
1) |[]
(ipgm pgm_cmd_grab_c |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

pgm_cmd_grab_s:(pgm |[]
[]
   (ptn (fact G:(goal (fact Command:(cmd grab [s] ::) Cmd_after: Cmd_before: ::) ::) ::) |[])
   (ptn (fact (mk.val e1 emulator_state [nil nil] :) After: Before: ::) |[])
[]
   (= (is_sim G) false)
   (< Cmd_after Before)
   (> Cmd_before After)
[]
   ; Inject the fact that the command was executed.
   (inj []
      (fact Command (+ After 20ms) Before 1 1)
      [SYNC_ONCE After 1 1 stdin nil]
   )
   ; We already checked that sphere is at the hand's position. TODO: What if cube is also there? 
   (inj []
      Next_state:(mk.val e1 emulator_state [nil s] 1)
      |[]
   )
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
   )
   (prb [1 "print" "pgm_cmd_grab_s from command:" [Command]])
1) |[]
(ipgm pgm_cmd_grab_s |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]


pgm_inject_mk_vals_attached_c_unattached_s:(pgm |[]
[]
   (ptn (fact (mk.val e1 emulator_state [Attached_obj_c: Attached_obj_s:] :) After: Before: ::) |[])
[]
   (<> Attached_obj_c nil)
[]
   (inj []
      Val_attached:(mk.val h holding [Attached_obj_c] 1)
      |[]
   )
   (inj []
      (fact Val_attached After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
1) |[]
(ipgm pgm_inject_mk_vals_attached_c_unattached_s |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

pgm_inject_mk_vals_unattached_c_attached_s:(pgm |[]
[]
   (ptn (fact (mk.val e1 emulator_state [Attached_obj_c: Attached_obj_s:] :) After: Before: ::) |[])
[]
   (<> Attached_obj_s nil)
[]
   (inj []
      Val_attached2:(mk.val h holding [Attached_obj_s] 1)
      |[]
   )
   (inj []
      (fact Val_attached2 After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
1) |[]
(ipgm pgm_inject_mk_vals_unattached_c_attached_s |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

pgm_inject_mk_vals_unattached_c_unattached_s:(pgm |[]
[]
   (ptn (fact (mk.val e1 emulator_state [Attached_obj_c: Attached_obj_s:] :) After: Before: ::) |[])
[]
   (= Attached_obj_s nil)
   (= Attached_obj_c nil)
[]
   (inj []
      Val_attached:(mk.val h holding [] 1)
      |[]
   )
   (inj []
      (fact Val_attached After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
1) |[]
(ipgm pgm_inject_mk_vals_unattached_c_unattached_s |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]
